#!/usr/bin/perl

# Copyright (C) 2008 Board of Regents of the University System of Georgia

# This file is part of YaketyStats (see http://yaketystats.org/).
#
# YaketyStats is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 2.
#
# YaketyStats is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with YaketyStats.  If not, see <http://www.gnu.org/licenses/>.

use strict;
use warnings;
use Cwd 'realpath';
our $g_dir = __FILE__;
$g_dir =~ s/\/[^\/]+$//;
$g_dir = realpath("$g_dir/..");
require "$g_dir/lib/include";

my (@data, $line);

# These are the defaults.  They could be semi-overridden by specifying a
# different interval in the client config file, but the RRD file would still have
# space for updates every $interval as defined below.
my $rrd_type = "GAUGE";
my $rrd_interval;

our ($g_os, $g_default_timeout, $g_host, $g_sep, $g_collector);
$main::g_host = get_hostname ();
$main::g_collector = 'io';

# If we haven't loaded subs.pl, then we've been run from the command-line.  That
# means we're in test mode.  So load include, define $g_host, and print results.
if (! defined (@ARGV) || (! defined ($ARGV[1]) && $ARGV[1] eq "calledfromcollect") ) {
  # TODO: There must be a better way to get this path!  I think the better
  # way is called "perl module" :)
  local $main::g_fileit_mode = "test";
  # Silence warning
  $main::g_fileit_mode = $main::g_fileit_mode;
  get_ignores ();
  $rrd_interval = 300;
  fileit ("You ran $g_collector manually; setting interval to $rrd_interval.");
  @data = doit ();
  foreach my $line (@data) {
    print "$line";
  }
  print "\n";
} else {
  if ( defined ($ARGV[0]) && $ARGV[0] =~ /^\d+$/ ) {
    $rrd_interval = $ARGV[0];
  } else {
    fileit ("Ack!  No interval for $g_collector.  Bailing.");
    exit ();
  }
  get_ignores ();
  @data = doit ();
  if ( defined ($data[0]) ) {
    bivalve (@data);
  } else {
    fileit ("Warning:  No data for $g_collector");
  }
}

sub doit {
  my ($cmd, $status, @data, $line, @return, $time);

  # For Linux,
  if ( $g_os eq "linux" ) {
    @return = linux ();
  }
  # HP-UX
  if ( $g_os eq "hpux" ) {
    @return = hpux ();
  }
  # Solaris
  if ( $g_os eq "solaris" ) {
    @return = solaris ();
  }
  return (@return);
}

# Linux:
#
# What a pain!  iostat output is different everywhere.  'sar -d' is the same but
# it uses goofy dev-* instead of useful device names, so translation is needed.
# Hmpf!
#
# So.  Use 'sar -d'.  Need that mapping thing for Solaris anyhow, so make similar
# mapping for Linux.

## NOTE:  HP-UX's sar has output for disks active during the time it's run!

##
## So, need to get list of all physical disks, then get mapping if needed, then
## gather stats, then put zeros in for all disks that had no output in sar.
## And gather the mapping infrequently--maybe once a day?  My pituti is hurting
## already!
##

## HP-UX:
## - Get full list of HP-UX disks with "vgdisplay -v | grep 'PV Name'".
## - No mapping is needed
## - Get stats via 'sar -d 5'

## Solaris:
## - Get mapping via solaris_disknames sd ssd dad
## - Get stats via 'sar -d 5 | grep -v ,' # , lines are for slices

## Linux:
## - Get mapping via parsing the dev-* strings
## - Get device numbers to ignore by searching for 'ramdisk' and 'device-mapper' 
#    in the Block: section of /proc/devices
## - Get stats via 'sar -d 5 | grep -v Average | grep 'dev[0-9]*-0', and then ignore
##   the devX-0 numbers where X is every number found in the above step.

## water_0:~ $ sar -d 1 | grep -v Average
## Linux 2.6.8-1-386 (water)       02/11/05
## 
## 08:30:20          DEV       tps  rd_sec/s  wr_sec/s
## 08:30:21       dev1-0      0.00      0.00      0.00
## 08:30:21       dev1-1      0.00      0.00      0.00
## 08:30:21       dev1-2      0.00      0.00      0.00
## 08:30:21       dev1-3      0.00      0.00      0.00
## 08:30:21       dev1-4      0.00      0.00      0.00
## 08:30:21       dev1-5      0.00      0.00      0.00
## 08:30:21       dev1-6      0.00      0.00      0.00
## 08:30:21       dev1-7      0.00      0.00      0.00
## 08:30:21       dev1-8      0.00      0.00      0.00
## 08:30:21       dev1-9      0.00      0.00      0.00
## 08:30:21      dev1-10      0.00      0.00      0.00
## 08:30:21      dev1-11      0.00      0.00      0.00
## 08:30:21      dev1-12      0.00      0.00      0.00
## 08:30:21      dev1-13      0.00      0.00      0.00
## 08:30:21      dev1-14      0.00      0.00      0.00
## 08:30:21      dev1-15      0.00      0.00      0.00
## 08:30:21       dev3-0     15.00      0.00    216.00
## 
## water_0:~ $ cat /proc/devices 
## Character devices:
##   1 mem
##   2 pty
##   3 ttyp
##   4 /dev/vc/0
##   4 tty
##   4 ttyS
##   5 /dev/tty
##   5 /dev/console
##   5 /dev/ptmx
##   7 vcs
##  10 misc
##  13 input
##  14 sound
##  29 fb
## 116 alsa
## 128 ptm
## 136 pts
## 171 ieee1394
## 180 usb
## 226 drm
## 253 pcmcia
## 254 devfs
## 
## Block devices:
##   1 ramdisk
##   3 ide0
## 254 device-mapper
## 
## 
## SunOS hermes 5.9 Generic_117171-12 sun4u    02/11/2005
## 
## 08:39:16   device        %busy   avque   r+w/s  blks/s  avwait  avserv
## 
## 08:39:17   md0              92     2.1     118   15487     0.0    17.9
##            md10              3     0.0       2       4     0.0    13.2
##            md11              0     0.0       0       0     0.0     0.0
##            md13              2     0.0       2      20     0.0    10.7
##            md14             21     0.3      53    3106     0.0     4.8
##            md20              2     0.0       2       4     0.0     9.2
##            md21              0     0.0       0       0     0.0     0.0
##            md23              2     0.0       2      20     0.0     9.0
##            md24             24     0.3      54    3048     0.0     5.0
##            md30              3     0.0       2       4     0.0    13.1
##            md31              0     0.0       0       0     0.0     0.0
##            md33              3     0.0       3      36     3.7     9.2
##            md34             31     0.4      86    4269     0.1     4.6
##            md40             17     0.2      19    2047     0.0     9.2
##            md41              0     0.0       0       0     0.0     0.0
##            md42             17     0.2      65    2186     0.0     3.1
##            md43              3     0.0       2      37     0.0    13.5
##            md50             92     2.1     118   15489     0.0    17.9
##            sd6               0     0.0       0       0     0.0     0.0
##            sd60              0     0.0       0       0     0.0     0.0
##            sd61              0     0.0       5     144     0.1     0.9
##            sd62              1     0.0      12     430     0.0     2.1
##            sd63              0     0.0       0       0     0.0     0.0
##            sd64              0     0.0       0       0     0.0     0.0
##            sd65              0     0.0       0       0     0.0     0.0
##            sd66              0     0.0       0       0     0.0     0.0

## eight1_0:~ # sar -d 5
## 
## HP-UX eight1 B.11.11 U 9000/800    02/11/05
## 
## 08:41:46   device   %busy   avque   r+w/s  blks/s  avwait  avserv
## 08:41:51   c6t6d0   14.82    2.33      28     232   14.62   22.33
##            c9t6d0   12.65    2.38      25     218   12.79   20.13
##           c10t8d0    4.15    0.50       8      78    5.67   15.77
##           c10t9d0    3.75    0.50       7      75    5.78   13.80
##           c16t0d0    0.79    0.50      23     308    5.83    1.09
##           c16t1d0    0.20    0.50       0       3    8.74    1.04
##           c16t4d4    0.40    0.50       1       9    8.04    4.53
##           c16t4d5    0.40    0.50       1       6    6.99    0.95


## - Get full list of HP-UX disks with "vgdisplay -v | grep 'PV Name'".
## - No mapping is needed
## - Get stats via 'sar -d 5'
sub hpux {
  my ($cmd, $time, $status, @data, $line, $pv, %stats, $busy, $avque, $rw, $blks,
      $avwait, $avserv, $var, $value, @return);

  $time = time ();

  # First, get all PVs
  $cmd = get_path ('vgdisplay');
  ($status, @data) = run_prg ("$cmd -v", $g_default_timeout);
  if ( $status != 0 ) {
    fileit ("Bad status for $cmd:  $status.  Output was:  @data\n");
    return (undef);
  }
  foreach $line (@data) {
    if ( $line =~ /PV Name/ ) {
      chomp ($line);
      $pv = (split (/\s+/, $line))[3];
      # Drop /dev/dsk/
      $pv = (split (/\//, $pv))[3];
      $stats{$pv}{'name'} = $pv;
    }
  }

  # The get data from sar
  $cmd = get_path ('sar');
  ($status, @data) = run_prg ("$cmd -d 5", $g_default_timeout);
  if ( $status != 0 ) {
    fileit ("Bad status for $cmd:  $status.  Output was:  @data\n");
    return (undef);
  }
  ##  0            1       2       3        4       5      6       7
  ## 08:41:46   device   %busy   avque   r+w/s  blks/s  avwait  avserv
  ## 08:41:51   c6t6d0   14.82    2.33      28     232   14.62   22.33
  ##            c9t6d0   12.65    2.38      25     218   12.79   20.13
  foreach $line (@data) {
    if ( $line =~ /c[0-9]+t[0-9]+d[0-9]+/ ) {
      chomp ($line);
      (undef, $pv, $busy, $avque, $rw, $blks, $avwait, $avserv) =
        split (/\s+/, $line);
      # TODO: There's a smarter way, I'm sure!  But maybe none that avoids eval.  Hmm.
      $stats{$pv}{'busy'}   = $busy;
      $stats{$pv}{'avque'}  = $avque;
      $stats{$pv}{'rw'}     = $rw;
      $stats{$pv}{'blks'}   = $blks;
      $stats{$pv}{'avwait'} = $avwait;
      $stats{$pv}{'avserv'} = $avserv;
      $stats{$pv}{'busy'}   = $busy;
      $stats{$pv}{'busy'}   = $busy;
      $stats{$pv}{'busy'}   = $busy;
    }
  }

  # Now loop through every PV and print the data (or 0 for no data)
 LOOP: foreach $pv (keys (%stats)) {
    if ( ignoreit ('io', $pv) ) {
      next LOOP;
    }
    foreach $var ('busy','avque','rw','blks','avwait','avserv') {
      if ( defined ($stats{$pv}{$var}) ) {
        $value = $stats{$pv}{$var};
      } else {
        $value = 0;
      }
      push (@return,
            "p=/$main::g_host/io/$var/$pv${g_sep}t=$rrd_type${g_sep}i=$rrd_interval${g_sep}ts=$time${g_sep}v=$value\n");
    }
  }
  return (@return);
}

#./solaris_diskinfo sd ssd dad
#Device Driver Instance Name =     ssd0, SVR4 name = /dev/dsk/c1t1d0s0
#Device Driver Instance Name =     ssd1, SVR4 name = /dev/dsk/c1t0d0s0
#Device Driver Instance Name =     sd60, SVR4 name = /dev/dsk/c3t21d0s0

## Solaris:
## - Get mapping via solaris_disknames sd ssd dad
## - Get stats via 'sar -d 5 | grep -v ,' # , lines are for slices

sub solaris {
  my ($cmd, $time, $status, @data, $line, $pv, %stats, $busy, $avque, $rw, $blks,
      $avwait, $avserv, $var, $value, @return, $short, $long, %short2long,
      $the_tness);

  $time = time ();

  # First, get the magic mapping
###     #Device Driver Instance Name =     ssd0, SVR4 name = /dev/dsk/c1t1d0s0
###     #Device Driver Instance Name =     ssd1, SVR4 name = /dev/dsk/c1t0d0s0
###     #Device Driver Instance Name =     sd60, SVR4 name = /dev/dsk/c3t21d0s0
###     $cmd = get_path ('solaris_disknames');
###     ($status, @data) = run_prg ("$cmd sd ssd dad", $g_default_timeout);
###     if ( $status != 0 ) {
###       fileit ("Bad status for $cmd:  $status.  Output was:  @data\n");
###       return (undef);
###     }
###   
###     foreach $line (@data) {
###       chomp ($line);
###       ($short, $long) = (split (/\s+/, $line))[5, 9];
###       $short =~ s/,//;
###       $long =~ s/.*dsk.//;
###       $long =~ s/s0$//;
###       $short2long{$short} = $long;
###     }

  # Snarf /etc/path_to_inst
  if ( ! open (F, "/etc/path_to_inst") ) {
    fileit ("Bad status for open /etc/path_to_inst: $!");
    return (undef);
  }
  my (%links, $ctd, $link, $instance, $driver);
  while ( <F> ) {
    $line = $_;
    if ( $line !~ /^#/ ) {
      chomp ($line);
      ($link, $instance, $driver) = split (/\s+/, $line);
      #print "line = $line, inst=$instance, drv=$driver.\n";
      $link =~ s/"//g;
      $driver =~ s/"//g;
      $link =~ s/^\///;
      if ( defined ($driver) && defined ($instance) ) {
	#print "recording $link = $driver $instance.\n";
	$links{$link} = "${driver}${instance}";
      }
    }
  }
  close (F);

  $cmd = get_path ('ls');
  ($status, @data) = run_prg ("$cmd -l /dev/dsk", $g_default_timeout);
  if ( $status != 0 ) {
    fileit ("Bad status for $cmd:  $status.  Output was:  @data\n");
    return (undef);
  }
  foreach $line (@data) {
    if ( $line !~ /^total/ ) {
      ($ctd, $link) = (split (/\s+/, $line))[8,10];
      #print "line = $line, ctd = $ctd, link = $link.\n";
      $link =~ s/[.][.]\/[.][.]\/devices\///g;
      $link =~ s/:.*//g;
      if ( defined ($links{$link}) ) {
	# drop slice
	$ctd =~ s/s.*//;
	#print "Hey, found short name for $ctd (link = $link): $links{$link}.\n";
	$short2long{$links{$link}} = $ctd;
      } else {
	# Eh, assume these are OK.  For us they are only emcpower devices
	#print "Hey, I'm helpless about $ctd (link = $link).\n";
	;
      }
    }
  }

  # Then get data from sar
  $cmd = get_path ('sar');
  ($status, @data) = run_prg ("$cmd -d 5", $g_default_timeout);
  if ( $status != 0 ) {
    fileit ("Bad status for $cmd:  $status.  Output was:  @data\n");
    return (undef);
  }
  ##  0            1       2       3        4       5      6       7
  ## 08:41:46   device   %busy   avque   r+w/s  blks/s  avwait  avserv
  ## 08:41:51   sd1     14.82    2.33      28     232   14.62   22.33
  ##            sd2     12.65    2.38      25     218   12.79   20.13
  LOOP: foreach $line (@data) {
    if ( $line =~ /(sd|ssd|dad)/ &&
         $line !~ /,/ ) {
      chomp ($line);
      (undef, $pv, $busy, $avque, $rw, $blks, $avwait, $avserv) =
        split (/\s+/, $line);
      # Vive la difference!
      # When you're using MPXIO on Solaris (10 at least) and have multiple paths to a LUN
      # you get multiple lines for each LUN in your sar -d output.  For example:
      # $ sar -d 1 1 | grep ssd18
      #    ssd18.t1          0     0.0       0       0     0.0     0.0
      #    ssd18.t2          0     0.0       0       0     0.0     0.0
      #    ssd18             0     0.0       0       0     0.0     0.0
      undef ($the_tness);
      if ( $pv =~ /[.]t[0-9]*$/ ) {
	$the_tness = $pv;
	$the_tness =~ s/^[^.]*[.]//g;
	$pv =~ s/[.]$the_tness//;
      } else {
	if ( !defined ($pv) || !defined ($short2long{$pv}) ) {
	  if ( !ignoreit ('io', $pv) ) {
	    fileit ("Ack, sar data for a disk that isn't mapped: $pv.  Skipping.");
	  }
	  next LOOP;
	}
      }
      $pv = $short2long{$pv};
      if ( defined ($the_tness) ) {
	$pv = "${pv}.${the_tness}";
      }
      # TODO: There's a smarter way, I'm sure!
      $stats{$pv}{'busy'}   = $busy;
      $stats{$pv}{'avque'}  = $avque;
      $stats{$pv}{'rw'}     = $rw;
      $stats{$pv}{'blks'}   = $blks;
      $stats{$pv}{'avwait'} = $avwait;
      $stats{$pv}{'avserv'} = $avserv;
      $stats{$pv}{'busy'}   = $busy;
      $stats{$pv}{'busy'}   = $busy;
      $stats{$pv}{'busy'}   = $busy;
    }
  }

  # Now loop through every PV and print the data (or 0 for no data)
 LOOP: foreach $pv (keys (%stats)) {
    if ( ignoreit ('io', $pv) ) {
      next LOOP;
    }

    foreach $var ('busy','avque','rw','blks','avwait','avserv') {
      if ( defined ($stats{$pv}{$var}) ) {
        $value = $stats{$pv}{$var};
      } else {
        $value = 0;
      }
      push (@return,
            "p=/$main::g_host/io/$var/$pv${g_sep}t=$rrd_type${g_sep}i=$rrd_interval${g_sep}ts=$time${g_sep}v=$value\n");
    }
  }
  return (@return);
}

## Linux:
## - Get mapping via parsing the dev-* for major and minor numbers..
## - Get device numbers to ignore by searching for 'ramdisk' and 'device-mapper' 
#    in the Block: section of /proc/devices
## - Get stats via 'sar -d 5 | grep -v Average | grep 'dev[0-9]*-0', and then ignore
##   the devX-0 numbers where X is every number found in the above step.
sub linux {
  my ($cmd, $time, $status, @data, $line, $dev, %stats, $tps, $read, $write,
      @return, $major, $minor, $doit, %map, $value, %majors, $var, $type,
      $files, %skipem);
  local *F;

  $time = time ();

  # First, get the list of major numbers that we care about
  # Read /proc/devices.  Ignore everything before Block:, and then ignore ramdisk
  # and device-mapper
  ## ...
  ## 226 drm
  ## 253 pcmcia
  ## 254 devfs
  ## 
  ## Block devices:
  ##   1 ramdisk
  ##   3 ide0
  ## 254 device-mapper
  if ( ! open (F, "/proc/devices") ) {
    fileit ("Can't open /proc/devices: $!");
    return (undef);
  }
  $doit = 0;
  while ( <F> ) {
    $line = $_;
    chomp ($line);
    #print "looking at line $line with doit = $doit\n";
    if ( $doit ) {
      $major = $line;
      $major =~ s/^\s*//;
      $major =~ s/\s.*//g;
      if ( $line !~ /ramdisk/ &&
           $line !~ /fd/ &&
           $line !~ /device-mapper/ ) {
        $majors{$major} = 1;
      } else {
        $skipem{$major} = 1;
      }
    }
    if ( $line =~ /^Block devices:/) {
      $doit = 1;
    }
  }

  # Map from major, minor to device name
  # Skip /dev/fd* and /dev/.*
  $cmd = get_path ('find');
  ($status, @data) = run_prg ("$cmd /dev -xdev -follow -type b",
			      $g_default_timeout, 1);

  $cmd = get_path ('ls');
  $files = join (' ', @data);

  $files =~ s/\n//g;
  ($status, @data) = run_prg ("$cmd -lL $files", $g_default_timeout, 1);
  foreach $line (@data) {
    chomp ($line);
    if ( $line =~ /,/ ) {
      ($type, $major, $minor, $dev) = (split (/\s+/, $line))[0, 4, 5, 9];
      # We only care about block devices where the final word is not /disc or /cd
      if ( $type =~ /^b/ &&
           $dev !~ /\/disc$/ &&
           $dev !~ /\/cd$/) {
        $major =~ s/,//;
        if ( defined ($majors{$major}) ) {
          $dev =~ s/\/dev//;
          $dev =~ s/^\///;
          $dev =~ s/\//./g;
          $map{"$major,$minor"} = $dev;
        }
      }
    }
  }

  # The get data from sar
  $cmd = get_path ('sar');
  ($status, @data) = run_prg ("$cmd -d 5", $g_default_timeout);
  # TODO: hack to work around Linux stupidity.
  if ( $status != 0 && $status != 1 ) {
    fileit ("Bad status for $cmd:  $status.  Output was:  @data\n");
    return (undef);
  }
  ## pork_0:/home/stats $ sar -d 1 | grep -v Average: | egrep 'dev[0-9]+-0'
  ## 14:48:06       dev1-0      0.00      0.00      0.00
  ## 14:48:06       dev8-0      0.00      0.00      0.00
  ## 14:48:06     dev254-0      0.00      0.00      0.00
  ## 14:48:06       dev3-0      0.00      0.00      0.00
  ##(14:49:05          DEV       tps  rd_sec/s  wr_sec/s)
  foreach $line (@data) {
    #print "line = $line\n";
    if ( $line !~ /Average:/ &&
         $line =~ /dev[0-9]+-0/ ) {
      ($dev, $tps, $read, $write) = (split (/\s+/, $line))[1, 2, 3, 4];
      $dev =~ s/dev//;
      ($major, $minor) = split (/-/, $dev);
      #print "looking for $major:$minor in map\n";
      if ( defined $map{"$major,$minor"}) {
        $dev = $map{"$major,$minor"};
        $stats{$dev}{'tps'}   = $tps;
        $stats{$dev}{'read'}  = $read;
        $stats{$dev}{'write'} = $write;
      } else {
        # Only complain if we're not skipping it intentionally.
        if ( ! $skipem{$major} ) {
          fileit ("Can't find mapping for $major, $minor.");
        }
      }
    }
  }

  # Now loop through every PV and print the data (or 0 for no data)
  LOOP: foreach $dev (keys (%stats)) {
    if ( ignoreit ('io', $dev) ) {
      next LOOP;
    }

    foreach $var ('tps','read','write') {
      if ( defined ($stats{$dev}{$var}) ) {
        $value = $stats{$dev}{$var};
      } else {
        $value = 0;
      }
      push (@return,
            "p=/$main::g_host/io/$var/$dev${g_sep}t=$rrd_type${g_sep}i=$rrd_interval${g_sep}ts=$time${g_sep}v=$value\n");
    }
  }
  return (@return);
}
