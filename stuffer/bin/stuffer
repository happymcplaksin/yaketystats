#!/usr/bin/perl

# Read logs and stuff data into RRDs.

$|=1;

use strict;
use warnings;
use RRDs;
use Cwd 'realpath';
use Fcntl ':mode';
use Data::Dumper;
$Data::Dumper::Purity = 1;
$Data::Dumper::Deepcopy = 1;
use Getopt::Std;

our $g_dir = __FILE__;
$g_dir =~ s/\/[^\/]+$//;
$g_dir = realpath("$g_dir/..");
require "$g_dir/lib/include";

# Globals
our ($g_statfile, $g_server_lock, $g_server_uri, $g_rrddir, $g_exit,
     $g_noexit, $g_sep, $g_max_log_entries, $g_max_rrd_entries,
     $g_lock_dir, $g_host, $g_collector);
our ($g_secs_per_hour, $g_secs_per_month, $g_secs_per_10years);
our ($g_server_logdir, @g_known_versions, $opt_d, $opt_l);
our ($g_debug, $g_debug_level, $g_deadlog_dir);

# Dump to RRD files after collecting this many timestamp/value pairs

my (%stats, $num_entries, $stuffer_lock, $stuffer_lock_fh, $stuffies);
# How many datapoints have we stuffed?
$stuffies = 0;
# End globals.

handle_args ();
get_config ("client");
get_config ("server");

# Lock so only one stuffer runs at a time
$stuffer_lock = "$g_lock_dir/stuffer";
$stuffer_lock_fh = return_fh ();
open ($stuffer_lock_fh, ">$stuffer_lock") || die "Can't open $stuffer_lock: $!";
if ( lock_fh ($stuffer_lock_fh) != 1 ) {
  fileit ("Can't get lock ($stuffer_lock).  Bailing.");
  exit (34);
}

my $show_times = 1;
my $start = time ();

# Main
$show_times && fileit ("Starting at " . localtime ($start));
version_1 ();

not_v1 ();

my $time = time ();
$show_times && fileit ("Ending at " . localtime ($time));
$show_times && fileit ("Took " . ($time - $start) . " seconds to stuff $stuffies data points.");

$g_collector = "stuffer";
# +.0001 = Cheating when it only takes no time at all
my $stuffs_per_sec = ($stuffies / (($time+.0001) - $start));
$show_times && fileit ("That's " . sprintf ("%.2f", $stuffs_per_sec) . " stuffs per second.");
my $rrd_type = 'GAUGE';
my $rrd_interval = 300;
$main::g_host = get_hostname ();
bivalve (("p=/$main::g_host/stuffspersec${g_sep}t=$rrd_type${g_sep}i=$rrd_interval${g_sep}ts=$time${g_sep}v=$stuffs_per_sec\n",
	  "p=/$main::g_host/numstuffs${g_sep}t=$rrd_type${g_sep}i=$rrd_interval${g_sep}ts=$time${g_sep}v=$stuffies\n"
	 ));
# End main

close ($stuffer_lock_fh);

sub version_1 {
  my (@host, $entry, $host, $file);
  my ($dir) = "$g_server_logdir/1.0";

  if ( @ARGV != 0 ) {
    @host= @ARGV;
  } else {
    if ( ! opendir (LOGDIR, "$dir") ) {
      fileit ("I can't open $dir: $!");
    } else {
      while ( $entry = readdir (LOGDIR) ) {
	$file = "${dir}/${entry}";
	if ( -f $file && $file !~ /lock$/ ) {
	  debug ("Adding host $entry to list", 100);
	  push(@host,$entry);
	}
      }
    }
    closedir(LOGDIR);
    foreach $host ( @host ) {
      readlog ("", $host, "1.0");
    }
  }
}

sub not_v1 {
  my (@versions, @hosts, @files, $version, $base_version, $host, $file);

  # For every dir in $g_server_logdir,
  debug ("Looking in $g_server_logdir.", 100);
  @versions = list_dir_entries ($g_server_logdir, \&S_IFDIR, 1);
  foreach $version (@versions) {
    debug ("Working on $version", 50);
    $base_version = basename ($version);
    if ( string_member ($base_version, @g_known_versions) ) {
      if ( $base_version eq "1.3" ) {
	@hosts = list_dir_entries ("$version", \&S_IFDIR, 1);
	#     For each dir in $dir/$v,
	foreach $host (@hosts) {
	  debug ("Working on host $host", 50);
	  @files = list_dir_entries ("$host", \&S_IFREG, 1);
	  debug ("Files are @files", 50);
	  foreach $file (@files) {
	    #       For each file,
	    if ( -r $file ) {
	      #         do it!!
	      debug ("Processing $file", 50);
	      readlog ($file, $host, $base_version);
	    } else {
	      fileit ("Hey, I can't read $file.");
	    }
	  }
	}
      } else {
	fileit ("I don't about $version.");
      }
    }
  }
}

sub readlog {
  my ($file, $host, $version) = @_;
  my ($cmd, $status, @data, $line, $ip, $uri);
  my ($value, $timestamp, $stat, $path, $type, $interval, $pos, $opos, $now,
      $lock);
  my ($start, $end, $fh, $lockit);
  local *F;

  $lockit = 1;
  $now = time();

  # Only allow one log2rrds process to run at a time
  #
  # If it's v1.0, lock in $g_server_logdir.
  $fh = return_fh ();
  if ( $version eq "1.0" ) {
    $lock = "$g_server_logdir/1.0/$host.lock";
  } else {
    # If it's v1.3, no locking needed!
    if ( $version eq "1.3" ) {
      $lockit = 0;
    } else {
      die "Hey, I don't know version $version.";
    }
  }
  if ( $lockit == 1 ) {
    debug ("Locking $lock.", 50);
    open ($fh, ">$lock") || die "Can't open $lock: $!";
    if ( lock_fh ($fh) != 1 ) {
      fileit ("Could not get lock ($lock).  Bailing.");
      exit (23);
    }
  }

  # Move file to rolledstats dir
  if ( $version eq "1.0" ) {
    $file = "$g_deadlog_dir/1.0/$host.$now";
    if ( ! rename("$g_server_logdir/1.0/$host", "$file") ) {
      fileit ("rename($g_server_logdir/1.0/$host, $file) failed: $!.  Ack!");
      return ();
    }
  }

  debug ("before reading $file log", 100);

  open (F, $file) || die "Can't open $file: $!";
  debug ("after opening log", 100);

  # Read the log and process the data
  LOOP: while ( <F> ) {
    $line = $_;

    if ( $line =~ /^$/ ) {
      next LOOP;
    }
    ($path, $type, $interval, $timestamp, $value) = parse_logline ($line, $version);
    # If there was trouble bubble, move on
    if ( ! defined ($path) ) {
      next LOOP;
    }
    $stat = $path;
    $stat =~ s/.*\///g;
    # Only keep certain characters
    $stat =~ s/[^[-]a-zA-Z_]//g;
    $path = dirname ($path);

    # Is it a range?
    if ( $timestamp =~ /-/ ) {
      ($start, $end) = (split (/-/, $timestamp));
      if ( $start !~ /^\d+$/ ||
	   $end !~ /^\d+$/ ) {
	fileit ("Bad range in line: $line");
	next LOOP;
      }
    } else {
      $start = $end = $timestamp;
    }
    for (;$start <= $end; $start += $interval) {
      debug ("add_and_maybe_dump ($value, $start, $stat, $path, $type, $interval)", 100);
      if ( add_and_maybe_dump ($value, $start, $stat, $path, $type,
			       $interval) != 0 ) {
	fileit ("FAILURE: add_and_maybe_dump ($value, $timestamp, $stat, $path, $type, $interval) but pressing on.\n");
      }
    }
  }

  dump_data ();

  if ( $lockit == 1 ) {
    debug ("Unlocking $lock.", 50);
    unlock_fh ($fh);
    close ($fh);
    unlink ($lock);
  }
  close (F);

  # Keep the file around in case it's needed for debugging.  Cleanup script should be run too.
  if ( $version eq "1.3" ) {
    my $dir = "$g_deadlog_dir/" . basename ($host);
    mkdirp ($dir);
    my $basename = basename ($file);
    my $new = "$basename.$now";
    debug ("Renaming $file to $dir/$new");
    if ( ! rename ($file, "$dir/$new") ) {
      fileit ("rename($file, $dir/$new) failed.  Ack!");
    }
  }
}

# Want to return:
#  ($path, $type, $interval, $timestamp, $value)
#
# v1.0 line looks like this:
#  168.24.82.53 03/22/05:16:14:07 /stats/stappend.php?path=/jojo.edu/net/lo/tx_err&dstype=DERIVE&interval=60&timestamp=1111520139&value=0
#
# v1.3 line looks like this where '^_' represents the Unit Separator character ($g_sep == ASCII 31):
# path=/jojo.edu/load/1-minute^_dst=GAUGE^_int=60^_ts=1146676981^_val=0.00
sub parse_logline {
  my ($line, $version) = @_;
  my ($path, $type, $interval, $timestamp, $value, @pairs, $pair, $k, $v, $sep);
  my ($prev_exit) = $g_exit;

  chomp ($line);
  # v1.0
  if ( $version eq "1.0" ) {
    (undef, undef, $line) = split (/\s+/, $line);
    if ( $line =~ /Lady&Tramp/ ) {
      return (undef);
    }
    if ( $line !~ /^path=/ && $line !~ /^$g_server_uri/ ) {
      fileit ("Help me!  I can't handle line: $line\n");
      return (undef);
    }
    $line =~ s/$g_server_uri\?//;
    $sep = '&';
  } else {
    if ( $version eq "1.3" ) {
      $sep = $g_sep;
    } else {
      fileit ("What version is $version?!?  Skipping $line");
      return (undef);
    }
  }

  @pairs = split ($sep, $line);
  foreach $pair (@pairs) {
    ($k, $v) = split (/=/, $pair);
    if ( !defined ($k) || !defined ($v) ) {
      fileit ("missing key or value for $pair in $line\n");
      return (undef);
    }
    # This may seem clumsy.  But it's not insecure like eval would be :)
    # Long keys are for version v1.0, short ones are for v1.3
    SWITCH: {
      if ( $k eq "path" || $k eq "p" ) {
	$path = $v; last SWITCH;
      }
      if ( $k eq "dstype" || $k eq "t" ) {
	$type = $v; last SWITCH;
      }
      if ( $k eq "interval" || $k eq "i" ) {
	$interval = $v; last SWITCH;
      }
      if ( $k eq "timestamp" || $k eq "ts" ) {
	$timestamp = $v; last SWITCH;
      }
      if ( $k eq "value" ||$k eq "v" ) {
	$value = $v; last SWITCH;
      }
    }
  }

  if ( check_values ($path, $type, $interval, $timestamp, $value) != 0 ) {
    fileit ("Skipping $line");
    return (undef);
  }
  return ($path, $type, $interval, $timestamp, $value)
}

sub check_values {
  my ($path, $type, $interval, $timestamp, $value) = @_;
  my $return = 0;

  if ( ! defined ($path) ||
       ! defined ($type) ||
       ! defined ($interval) ||
       ! defined ($timestamp) ||
       ! defined ($value) ) {
    fileit ("Some values are undefined.");
    return (1);
  }
  if ( $path !~ /^[[:ascii:]]+$/ ) {
    fileit ("Path contains non-ASCII characters: $path.");
    $return++;
  }
  if ( $type ne "GAUGE" &&
       $type ne "COUNTER" &&
       $type ne "DERIVE" &&
       $type ne "ABSOLUTE" ) {
    fileit ("Type is not one of GAUGE, COUNTER, DERIVE, and ABSOLUTE: $type.");
    $return++;
  }
  if ( $interval !~ /^\d+$/ ) {
    fileit ("Interval is not a number: $interval.");
    $return++;
  }
  if ( $timestamp !~ /^[\d-]+$/ ) {
    fileit ("Timestamp is not an integer or a range: $timestamp.");
    $return++;
  }
  if ( $value !~ /^[\d.]+$/ ) {
    fileit ("Value is not an integer or float: $value.");
    $return++;
  }
  return ($return);
}

# MAYBE TODO: dumphash always returns 0.  If it stays that way, should
# remove the checking below....well, dumphash always returns 0 because it
# just warns if there's trouble...is *that* good?  It *seems* good because
# 99.9% of the time everything will work and you don't care about a few
# missed data points.  If everything suddenly fails for a while, maybe you
# want everything to stop so you can fix it without having to stitch
# together RRD files by hand.
#
# 5/3/6: Sam and Happy decided we shouldn't touch this.  If we read this
# TODO again and still agree, delete it!
sub add_and_maybe_dump {
  my ($value, $timestamp, $stat, $path, $type, $interval) = @_;

  push ( @{ $stats{"${g_rrddir}/${path}/$stat.rrd"}{$type}{$interval} },
         "$timestamp:$value");

  $num_entries++;
  debug ("$num_entries (max = $g_max_log_entries) stats so far.\n", 100);
  if ( $num_entries >= $g_max_log_entries ) {
    debug ("Dumping hash with $num_entries entries.\n", 100);
    debug (Data::Dumper->Dump ( [\%stats], ['*stats'] ), 100);
    if ( dump_data () == 0 ) {
      return (0);
    } else {
      return (1);
    }
  }
  return (0);
}

sub dump_data {
  my ($rrdfile, $type, $interval, $stat, $pair, $count, @pairs, $aref, @a, $total, $dumpstart);

#  $dumpstart = time ();
#  debug ("dumphash starting", 100);
  $total = 0;
  foreach $rrdfile (keys (%stats)) {
    foreach $type (keys (%{ $stats{$rrdfile} })) {
      foreach $interval (keys (%{ $stats{$rrdfile}{$type} })) {
        $count = 0;
        debug ("Working on $rrdfile", 100);
        foreach $pair ( @{ $stats{$rrdfile}{$type}{$interval} } ) {
          push (@pairs, $pair);
          $count++;
	  $total++;
          if ( $count >= $g_max_rrd_entries ) {
            if ( rrdit ($rrdfile, $type, $interval, @pairs) != 0 ) {
              fileit ("Warning:  rrdit ($rrdfile, $type, $interval, @pairs) failed.  Pressing on!");
            }
            $count = 0;
            undef (@pairs);
          }
        }
        if ( $count > 0 ) {
          if ( rrdit ($rrdfile, $type, $interval, @pairs) != 0 ) {
              fileit ("Warning:  rrdit ($rrdfile, $type, $interval, @pairs) failed.  Pressing on!");
          }
          $count = 0;
          undef (@pairs);
        }
      }
    }
  }
  undef (%stats);
#  fileit ("dumphash: It took " . (time () - $dumpstart) . " seconds to stuff $total data points");
  $stuffies += $total;

  debug ("Just emptied stats hash.", 100);
  debug (Data::Dumper->Dump ( [\%stats], ['*stats'] ), 100);
  $num_entries = 0;
  return (0);
}

sub rrdit {
  my ($rrdfile, $type, $interval, @valuepairs) = @_;
  my ($dir, $last, $ERR, $ds_name);

  debug ("In rrdit with ($rrdfile, $type, $interval, @valuepairs) = @_\n", 100);

  if ( ! defined ($interval) ) {
    fileit ("defaulting interval to 60 seconds for $rrdfile");
    $interval = 60;
  }

  $dir = "$rrdfile";
  $dir =~ s|/[^/]+.rrd$||;
  # Make sure directory exists
  if ( mkdirp ($dir) != 0 ) {
      return (1);
  }

  # TODO:  Should client send min, max too?
  # TODO:  Should they all start at second 0?  That seems nice :)
  #
  # 5/3/6: Sam and Happy decided we shouldn't touch this.  If we read this
  # TODO again and still agree, delete it!
  debug ("calling maybe_create_rrdfile.\n", 100);
  $ds_name = basename ($rrdfile);
  $ds_name =~ s/[.]rrd$//;
  # DS names can be up to 19 characters long
  if ( length ($ds_name) > 19 ) {
    $ds_name =~ s/.*(.{19})$/$1/;
  }

  if ( maybe_create_rrdfile ($ds_name, $rrdfile, $interval, $type, 0, "U", undef)
       != 0 ) {
    return (1);
  }

  # update the rrd
  debug ("Updating $rrdfile with @valuepairs", 100);
  RRDs::update ($rrdfile, @valuepairs);
  $ERR = RRDs::error;
  if ( $ERR ) {
    debug ("Update failure: $ERR", 100);
    fileit ("ERROR while updating $rrdfile: $ERR\n");
    return (1);
  }
  debug ("Updating successful", 100);
  return (0);
}

sub maybe_create_rrdfile {
  my ($dsname, $rrdfile, $step, $type, $min, $max, $start) = @_;
  my ($rrderr, $secs_per_step, $high_res_secs, $heartbeat, 
      $high_res_steps_per_cdp, $high_res_secs_per_cdp, $high_res_rows,
      $low_res_steps_per_cdp, $low_res_secs_per_cdp, $low_res_rows, $time,
      $command);

  if ( -e $rrdfile ) {
    return (0);
  }

  debug ("Creating $rrdfile.\n", 100);

  $secs_per_step = $step;

  # Sanity check
  if ( $secs_per_step > $g_secs_per_10years ) {
    fileit ("Good grief!  You don't sample enough.  I'm outta here!\n");
    return (1);
  }

  # If we're sampling hourly or less frequently then we just want 10 years'
  # worth of high res
  if ( $secs_per_step < $g_secs_per_hour ) {
    $high_res_secs = $g_secs_per_month;
  }
  else {
    $high_res_secs = $g_secs_per_10years;
  }

  $heartbeat = 2 * $secs_per_step;
  $high_res_steps_per_cdp = 1;
  $high_res_secs_per_cdp = $high_res_steps_per_cdp * $secs_per_step;
  $high_res_rows = $high_res_secs / $high_res_secs_per_cdp;

  # If we're sampling hourly or less frequently then we just want high res
  if ( $secs_per_step < $g_secs_per_hour ) {
    $low_res_steps_per_cdp = $g_secs_per_hour / $secs_per_step;
    $low_res_secs_per_cdp = $low_res_steps_per_cdp * $secs_per_step;
    $low_res_rows = $g_secs_per_10years / $low_res_secs_per_cdp;
  }

  # Start 60 days ago
  $time = time () - (86400*60);
  if (defined ($start)) {
    $time = $start;
  }

  $command = "RRDs::create (\"$rrdfile\", \"-b $time\", \"-s $step\",";
  # TODO:  To yabba or not to yabba
  #$command = "$command \"DS:$dsname:$type:$heartbeat:$min:$max\"";
  $command = "$command \"DS:yabba:$type:$heartbeat:$min:$max\"";
  #$command = "$command, \"RRA:AVERAGE:0.5:$high_res_steps_per_cdp:$high_res_rows\"";
  $command = "$command, \"RRA:MAX:0.5:$high_res_steps_per_cdp:$high_res_rows\"";
  # If we're sampling hourly or less frequently, we just want high_res
  if ( $secs_per_step < $g_secs_per_hour ) {
    #$command = "$command, \"RRA:AVERAGE:0.5:$low_res_steps_per_cdp:$low_res_rows\"";
    $command = "$command, \"RRA:MAX:0.5:$low_res_steps_per_cdp:$low_res_rows\"";
  }
  $command = "$command);";

  debug ("$command\n", 100);
  eval $command;
  $rrderr = RRDs::error ();
  if ( $rrderr ) {
    fileit ("ERROR while creating $rrdfile: $rrderr\n");
    return (1);
   }
  return (0);
}

sub epoch_2_string {

  my ($epoch) = $_[0];
  my ($min, $hour, $mday, $mon, $year, $date);

  #   0    1    2     3     4    5     6     7     8
  #($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
  #                                            localtime(time);
  ($min, $hour, $mday, $mon, $year) = (localtime ($epoch))[1, 2, 3, 4, 5];
  $year += 1900;
  $mon += 1;
  $date = sprintf ("%.2d/%.2d/%.2d %.2d:%.2d", $mon, $mday, $year, $hour, $min);
  return ($date);
}

# Call 'mkdir -p' if $dir doesn't exist
sub mkdirp {
  my ($dir) = @_;
  my ($cmd, $status, @data);

  if ( ! -e $dir ) {
    $cmd = "/bin/mkdir -p $dir";
    ($status, @data) = run_prg ($cmd, 10);
    if ( $status != 0 ) {
      fileit ("Bad status for $cmd: $status.  Output was:  @data\n");
      return (1);
    }
  }
  return (0);
}

# -d turns on debugging
# -l LEVEL sets debug level
sub handle_args {
  getopts('pdol:');  # -p, -d, and o are boolean; l takes an argument
  # Sets $opt_* as a side effect.

  if ( defined ($opt_d) ) {
    $g_debug = 1;
    debug ("Debug is ON!");
  }
  if ( defined ($opt_l) && $opt_l =~ /^\d+$/ ) {
    $g_debug_level = $opt_l;
    debug ("Debug level set to $g_debug_level");
  }
}
